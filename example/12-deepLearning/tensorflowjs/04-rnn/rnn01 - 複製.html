<html>
<body>
<script src='https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.10.0'></script> 
<script>
/*
注意： RNN 的輸入是 3D 的 ...

        this.testXsForDisplay = this.testXs.slice(
            [0, 0, 0],
            [numTestExamples, this.testXs.shape[1], this.testXs.shape[2]]);
      }

      const examples = [];
      const isCorrect = [];
      tf.tidy(() => {
        const predictOut = this.model.predict(this.testXsForDisplay);
        for (let k = 0; k < numTestExamples; ++k) {
          const scores =
              predictOut
                  .slice(
                      [k, 0, 0], [1, predictOut.shape[1], predictOut.shape[2]])
                  .as2D(predictOut.shape[1], predictOut.shape[2]);
          const decoded = this.charTable.decode(scores);
          examples.push(this.testData[k][0] + ' = ' + decoded);
          isCorrect.push(this.testData[k][1].trim() === decoded.trim());
        }
...
問題是： inputShape 中的 maxLen 是指甚麼呢？

  const maxLen = digits + 1 + digits;

例如： 032+437 = 469 這樣的話，digits 就是 3, vocatbularySize 就是 10 (0-9)，


    case 'LSTM':
      model.add(tf.layers.lstm({
        units: hiddenSize,
        recurrentInitializer: 'glorotNormal',
        inputShape: [maxLen, vocabularySize]
      }));
*/

const inputs = [0,0,1,0,0,1,0,0,1,0,0,1]
const outs = [0,1,0,0,1,0,0,1,0,0,1,0]

const LEARNING_RATE = 0.15

function build() {
  /*
  const model = tf.sequential()
  model.add(tf.layers.dense({units: 5, inputShape: [7], useBias: true, activation: 'relu'}))
  model.add(tf.layers.dense({units: 10, useBias: true, activation: 'relu'}))
  model.add(tf.layers.dense({units: 10, activation: 'softmax'}))
  const optimizer = tf.train.sgd(LEARNING_RATE);
  model.compile({ loss: 'binaryCrossentropy', optimizer: optimizer, metrics: ['accuracy'] })
  */
  const model = tf.sequential()
  // model.add(tf.layers.lstm({ units: 1, inputShape: [1, 1]}))
  model.add(tf.layers.simpleRNN({ units: 1, inputShape: [1, 1]}))
  // model.add(tf.layers.timeDistributed({layer: tf.layers.dense({units: vocabularySize})}));
  // model.add(tf.layers.activation({activation: 'softmax'}))
  model.compile({
    loss: 'binaryCrossentropy',
    optimizer: 'adam',
    metrics: ['accuracy']
  })
  return model
}

/*
  encodeBatch(strings, numRows) {
    const numExamples = strings.length;
    const buf = tf.buffer([numExamples, numRows, this.size]);
    for (let n = 0; n < numExamples; ++n) {
      const str = strings[n];
      for (let i = 0; i < str.length; ++i) {
        const char = str[i];
        if (this.charIndices[char] == null) {
          throw new Error(`Unknown character: '${char}'`);
        }
        buf.set(1, n, i, this.charIndices[char]);
      }
    }
    return buf.toTensor().as3D(numExamples, numRows, this.size);
  }
*/


async function train(model, inputs, outs) {
  const xs = tf.tensor3d(inputs, [inputs.length, 1, 1])
  // .as3D(numExamples, numRows, this.size);
  const ys = tf.tensor3d(outs, [outs.length, 1, 1])
  
  for (let i = 1; i < 100 ; ++i) {
    // let xi = xs.get(i), yi = ys.get(i)
    // console.log('xi=', xi, 'yi=', yi)
    // const h = await model.fit(xs, ys, { batchSize: 1, epochs: 1 })
    console.log('i=', i)
    for (let j = 0; j<xs.shape[0]; j++) {
      console.log('j=', j)
      // let xj=xs.slice([j,0,0], [1, xs.shape[1], xs.shape[2]]).as2D(xs.shape[1], xs.shape[2])
      // let yj=ys.slice([j,0,0], [1, ys.shape[1], ys.shape[2]]).as2D(ys.shape[1], ys.shape[2])
      let xj=xs.slice([j,0,0], [1, xs.shape[1], xs.shape[2]])
      let yj=ys.slice([j,0,0], [1, ys.shape[1], ys.shape[2]])
      const h = await model.fit(xj, yj, { batchSize: 1, epochs: 1, validationData: [xs, ys] })
      // const h = await model.fit(xs, ys, { batchSize: 1, epochs: 1, validationData: [xs, ys] })
      // const h = await model.fit(xj, yj, { batchSize: 1, epochs: 1 })
      console.log('Loss after Epoch ' + i + ' : ' + h.history.loss[0])
      if (h.history.loss[0] < 0.01) break
    }
    
  }
}

function predict(model, inputs) {
  for (let i=0; i<inputs.length; i++) {
    console.log('i:', inputs[i], 'o:', outs[i], '=>', model.predict(tf.tensor3d([[[inputs[i]]]])).toString())
  }
}

async function run() {
  try {
    console.log('build...')
    let model = build()
    console.log('train...')
    await train(model, inputs, outs)
    console.log('predict...')
    predict(model, inputs)
  } catch (error) {
    console.log('error=', error)
  }
}

run()
</script>
</body>
</html>
